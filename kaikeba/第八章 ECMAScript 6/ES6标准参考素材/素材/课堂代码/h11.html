<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6标准</title>
</head>
<body>
    <h2>对象的新增方法</h2>
    <script>
        //1. Object.is() 比较两个值是否严格相等
        // console.log(Object.is('foo', 'foo')); // true
        // console.log(Object.is({}, {})); //false

        // console.log(+0 === -0); //true
        // console.log(NaN === NaN); // false

        // console.log(Object.is(+0, -0)); // false
        // console.log(Object.is(NaN, NaN)); // true

        //2. Object.assign() 用于对象的合并
        // const b1 = {a:1};
        // const b2 = {b:2,a:10};
        // const b3 = {c:3,b:20};
        // Object.assign(b1,b2,b3);
        // console.log(b1);
        //注意：多个源对象有同名属性，则后面的属性会覆盖前面的属性

        //3. Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。
        // const obj = {
        //     foo: 123,
        //     get bar() { return 'abc' }
        // };

        // console.log(Object.getOwnPropertyDescriptors(obj));
        

        //5. Object.keys()，Object.values()，Object.entries()
        var obj1 = { foo: 'bar', baz: 42 };
        console.log(Object.keys(obj1)); //["foo", "baz"]  
        console.log(Object.values(obj1)); //["bar", 42]  
        console.log(Object.entries(obj1)); //[["foo","bar"],["baz", 42]]


        let {keys, values, entries} = Object;
        let obj2 = { a: 1, b: 2, c: 3 };

        for (let key of keys(obj2)) {
        console.log(key); // 'a', 'b', 'c'
        }

        for (let value of values(obj2)) {
        console.log(value); // 1, 2, 3
        }

        for (let [key, value] of entries(obj2)) {
        console.log([key, value]); // [['a', 1], ['b', 2], ['c', 3]]
        }

        //6. Object.fromEntries() 是Object.entries()的逆操作，用于将一个键值对数组转为对象。
        const ob = Object.fromEntries([
            ['foo', 'bar'],
            ['baz', 42]
        ])
        console.log(ob); // { foo: "bar", baz: 42 }

    </script>
</body>
</html>